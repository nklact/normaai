name: Desktop App Release

on:
  push:
    branches: [main, master] # Triggers on every push to master
  workflow_dispatch: # Allow manual triggering from GitHub UI

jobs:
  create-release:
    permissions:
      contents: write
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create-release.outputs.result }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Get version from package.json
        run: echo "PACKAGE_VERSION=$(node -p "require('./package.json').version")" >> $GITHUB_ENV

      - name: Create release
        id: create-release
        uses: actions/github-script@v7
        with:
          script: |
            const tagName = `v${process.env.PACKAGE_VERSION}`;

            // Check if release already exists
            try {
              const { data: existingRelease } = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });
              console.log(`Release ${tagName} already exists, using existing release ID`);
              return existingRelease.id;
            } catch (error) {
              if (error.status === 404) {
                // Release doesn't exist, create it
                const { data } = await github.rest.repos.createRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: tagName,
                  name: `Norma AI Desktop v${process.env.PACKAGE_VERSION}`,
                  body: 'See the CHANGELOG for details.',
                  draft: true,
                  prerelease: false
                });
                return data.id;
              }
              throw error;
            }

  build-tauri:
    needs: create-release
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-latest'
            args: '--target universal-apple-darwin'
          - platform: 'ubuntu-latest'
            args: ''
          - platform: 'windows-latest'
            args: ''

    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install dependencies (Ubuntu only)
        if: matrix.platform == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install Node dependencies
        run: npm ci

      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0.5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}
          # EmailJS configuration for verification emails
          VITE_EMAILJS_SERVICE_ID: ${{ secrets.VITE_EMAILJS_SERVICE_ID }}
          VITE_EMAILJS_VERIFICATION_TEMPLATE_ID: ${{ secrets.VITE_EMAILJS_VERIFICATION_TEMPLATE_ID }}
          VITE_EMAILJS_PUBLIC_KEY: ${{ secrets.VITE_EMAILJS_PUBLIC_KEY }}
        with:
          releaseId: ${{ needs.create-release.outputs.release_id }}
          args: ${{ matrix.args }}
          includeUpdaterJson: true

      - name: Upload Windows installer to FTP
        if: matrix.platform == 'windows-latest'
        run: |
          # Find the generated setup.exe file
          $exeFile = Get-ChildItem -Path "src-tauri\target\release\bundle\nsis" -Filter "*-setup.exe" -Recurse | Select-Object -First 1

          if ($exeFile) {
            Write-Host "Found installer: $($exeFile.FullName)"

            # Copy and rename to consistent name
            $targetFile = "Norma-AI-Setup.exe"
            Copy-Item $exeFile.FullName -Destination $targetFile

            Write-Host "Renamed to: $targetFile"
            Write-Host "Uploading to FTP server..."

            # Upload via FTPS (FTP over TLS) using curl with directory creation
            $exitCode = 0
            curl.exe -T $targetFile `
              --user "${{ secrets.FTP_USERNAME }}:${{ secrets.FTP_PASSWORD }}" `
              --ftp-ssl `
              --ftp-create-dirs `
              -k `
              -v `
              "ftp://normaai.rs/downloads/$targetFile"
            $exitCode = $LASTEXITCODE

            if ($exitCode -eq 0) {
              Write-Host "✓ Upload completed successfully!"
            } else {
              Write-Host "✗ Upload failed with exit code: $exitCode"
              Write-Host "Trying alternative path (root directory)..."

              # Try uploading to root if /downloads/ failed
              curl.exe -T $targetFile `
                --user "${{ secrets.FTP_USERNAME }}:${{ secrets.FTP_PASSWORD }}" `
                --ftp-ssl `
                -k `
                -v `
                "ftp://normaai.rs/$targetFile"

              if ($LASTEXITCODE -eq 0) {
                Write-Host "✓ Upload to root completed successfully!"
              } else {
                Write-Host "✗ Upload failed. Please check FTP permissions and path."
                exit 1
              }
            }
          } else {
            Write-Host "No installer found to upload"
          }
        shell: pwsh

  publish-release:
    permissions:
      contents: write
    runs-on: ubuntu-latest
    needs: [create-release, build-tauri]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Get version from package.json
        run: echo "PACKAGE_VERSION=$(node -p "require('./package.json').version")" >> $GITHUB_ENV

      - name: Generate latest.json for updater
        uses: actions/github-script@v7
        env:
          release_id: ${{ needs.create-release.outputs.release_id }}
        with:
          script: |
            const fs = require('fs');
            const releaseId = process.env.release_id;
            const version = process.env.PACKAGE_VERSION;

            // Get release details
            const { data: release } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });

            // Get all release assets
            const { data: assets } = await github.rest.repos.listReleaseAssets({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });

            // Build platforms object
            const platforms = {};

            // Helper to find signature for an asset
            const findSignature = (assetName) => {
              const sigAsset = assets.find(a => a.name === `${assetName}.sig`);
              return sigAsset ? sigAsset.browser_download_url : null;
            };

            // Windows x86_64
            const windowsAsset = assets.find(a => a.name.includes('setup.exe') || a.name.includes('x64-setup.exe'));
            if (windowsAsset) {
              const sigUrl = findSignature(windowsAsset.name);
              if (sigUrl) {
                // Download signature content
                const sigResponse = await fetch(sigUrl);
                const signature = await sigResponse.text();

                platforms['windows-x86_64'] = {
                  signature: signature.trim(),
                  url: windowsAsset.browser_download_url
                };
              }
            }

            // macOS universal (if using universal build)
            const macUniversalAsset = assets.find(a =>
              a.name.includes('.app.tar.gz') && a.name.includes('universal')
            );
            if (macUniversalAsset) {
              const sigUrl = findSignature(macUniversalAsset.name);
              if (sigUrl) {
                const sigResponse = await fetch(sigUrl);
                const signature = await sigResponse.text();

                platforms['darwin-universal'] = {
                  signature: signature.trim(),
                  url: macUniversalAsset.browser_download_url
                };
              }
            }

            // macOS aarch64 (Apple Silicon)
            const macAarch64Asset = assets.find(a =>
              a.name.includes('.app.tar.gz') && a.name.includes('aarch64')
            );
            if (macAarch64Asset) {
              const sigUrl = findSignature(macAarch64Asset.name);
              if (sigUrl) {
                const sigResponse = await fetch(sigUrl);
                const signature = await sigResponse.text();

                platforms['darwin-aarch64'] = {
                  signature: signature.trim(),
                  url: macAarch64Asset.browser_download_url
                };
              }
            }

            // macOS x86_64 (Intel)
            const macX64Asset = assets.find(a =>
              a.name.includes('.app.tar.gz') && a.name.includes('x64') && !a.name.includes('universal')
            );
            if (macX64Asset) {
              const sigUrl = findSignature(macX64Asset.name);
              if (sigUrl) {
                const sigResponse = await fetch(sigUrl);
                const signature = await sigResponse.text();

                platforms['darwin-x86_64'] = {
                  signature: signature.trim(),
                  url: macX64Asset.browser_download_url
                };
              }
            }

            // Linux x86_64
            const linuxAsset = assets.find(a => a.name.includes('.AppImage.tar.gz'));
            if (linuxAsset) {
              const sigUrl = findSignature(linuxAsset.name);
              if (sigUrl) {
                const sigResponse = await fetch(sigUrl);
                const signature = await sigResponse.text();

                platforms['linux-x86_64'] = {
                  signature: signature.trim(),
                  url: linuxAsset.browser_download_url
                };
              }
            }

            // Create latest.json
            const latestJson = {
              version: `v${version}`,
              notes: release.body || 'See the CHANGELOG for details.',
              pub_date: new Date().toISOString(),
              platforms
            };

            // Write to file
            fs.writeFileSync('latest.json', JSON.stringify(latestJson, null, 2));
            console.log('Generated latest.json:');
            console.log(JSON.stringify(latestJson, null, 2));

      - name: Upload latest.json to release
        uses: actions/github-script@v7
        env:
          release_id: ${{ needs.create-release.outputs.release_id }}
        with:
          script: |
            const fs = require('fs');
            const releaseId = process.env.release_id;

            // Get existing assets and delete latest.json if it exists
            const { data: assets } = await github.rest.repos.listReleaseAssets({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });

            const existingLatestJson = assets.find(a => a.name === 'latest.json');
            if (existingLatestJson) {
              await github.rest.repos.deleteReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                asset_id: existingLatestJson.id
              });
              console.log('✓ Deleted existing latest.json');
            }

            // Read the generated latest.json
            const latestJson = fs.readFileSync('latest.json');

            // Upload as release asset
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              name: 'latest.json',
              data: latestJson
            });

            console.log('✓ Uploaded latest.json to release');

      - name: Publish release
        id: publish-release
        uses: actions/github-script@v7
        env:
          release_id: ${{ needs.create-release.outputs.release_id }}
        with:
          script: |
            github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: process.env.release_id,
              draft: false,
              prerelease: false
            })
